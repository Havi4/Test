# 1.12 为什么实例化？

##为什么实例化？
虽然没有像实例这样的，但是一个类型对象自己也是个对象。我们知道这个是因为一个对象类型可以被发送消息：一个对象类型可以可以被看作一个命名域并且和其他命名域分离。更重要的是，由于类和静态成员的存在，因此可以直接调用一个类的方法，甚至是结构体、枚举；或者获取一个类的属性、结构体、枚举。为什么实例要存在？

答案主要和实例属性有关系。实例属性的值和一个特殊实例有关。这是实例的真正有用和强大之处。

再次考虑下**Dog**类。我将要给这个类添加一个属性**name**和方法**bark**；记住这些是实例属性和实例方法：
```swift
class Dog (){
  var name = ""
  func bark() {
    print("woof")
  }
}
```
一个**Dog**实例创建好了名字为空（一个空的字符串）。但是**name**属性是一个**var**，所以一旦我们创建了任何**Dog**实例，我们可以给这个属性赋新值：
```swift
let dog1 = Dog()
dog1.name = "fido"
```
我们也可以获取**Dog**实例的*name*属性
```swift
let dog1 = Dog()
dog1.name = "fido"
print(dog1.name) //"fido"
```
更重要的是我们可以创建多个**Dog**实例，不同的*Dog*实例可以具有不同的**name**值：图1-2

```swift
let dog1 = Dog()
dog1.name = "fido"
let dog2 = Dog()
dog2.name = "rover"
print(dog1.name) // "fido"
print(dog2.name) //"rover"
```
![1-2](屏幕快照 2016-05-10 22.12.12.png)
注意**Dog**实例的**name**属性和这个**Dog**实例赋值给哪个变量没有关系。那个变量只是个存放**Dog**实例的盒子。你可以将值从一个盒子赋值给另外一个。但是实例自己维持自己的内部完整：

```swift
let dog1 = Dog()
dog1.name = "fido"
var dog2 = Dog()
dog2.name = "rover"
print(dog1.name) // "fido"
print(dog2.name) // "rover"
dog2 = dog1
print(dog2.name) // "fido"
```
上面的代码并没有改变*rover*名字；他只是改变了**dog2**里面的值，使用*fido*替换了*rover*。

面向对象编程的威力开始出现。**Dog**对象类型定义了一个**Dog**类型应该是什么样子的。我们的**Dog**类型定义了一个**Dog**实例--每一个实例，任何实例--都有一个名为**name**的属性和名为**bark**的方法。但是每个**Dog**实例都有自己的**name**属性。他们是不同的实例并且在内部维持他们的状态。所以多个类型相同的对象表现出的行为相似--*Fido*和*Rover*都可以bark，都可以被发送bark消息--但他们又都是不同的实例因此具有的不同的属性值：*Fido's*的name是*Fido*,*Rover's*的名字是*rover*。


> 对于1和2也是同样的道理，尽管这个结果更加明显。一个Int类型有一个value属性。1的值是1，2的值是2.但是在现实生活中就没有意义了，因为很明显你不会去修改1的值。

$$因为在Swift中1、2也是对象，但是这个对象属性我们不会去修改$$

所以一个实例是它的自己类型的实例方法的反应，但并不只是；他同样是实例属性的集合。对象类型负责实例的属性有哪些，但是不负责这些属性的值。这些属性的值可能随着程序的运行改变，并且只适合特定的实例。一个实例是特定属性值的集合。

一个实例不仅负责一个属性的值，而且负责这个属性的生命周期。设想我们创建了**Dog**的一个实例并且给它的*name*属性赋值*Fido*。那么这个实例就会保持*Fido*只要我们不使用其他值替换它并且这个实例不销毁。

简单来说，意思实例即是代码也是数据。它从它类型获得的代码在一定意义上是和这个类型的其他实例共享的，但是data是独有的。只要实例存在value就存在。此时，实例具有一个状态--收集自己属性值的一个集合。一个实例就是一个维持状态的设备。是一个保存数据的盒子。

