# 2.2 外部化参数名

## 外部参数名称

一个函数可以外部化它的参数列表。外部参数名称必须以参数的标签作出现在函数中。这样做的好处有以下几个：

* 它可以表明每个参数的目的；每个参数标签可以提供这个参数对这个函数行为影响的补充说明。
* 可以和其他函数进行区分；两个函数可以有相同的函数名，函数类型，但是外部参数名不同。
* 可以帮助Swift更好的对接OC和Cocoa--他们的函数参数都具有外部参数名。

为了外部化参数名称，在声明函数的时候把外部参数放到内部参数名之前，以空格分割。外部参数名可以内部参数名相同，也可以不同。Swift中外部参数很标准，但是，这里有个规则：默认情况下，除了第一个参数，剩下的参数默认是外部参数化的。因此，如果你希望一个参数外部化，这个参数不是第一个参数，且内部参数名和外部参数名相同，这个时候你不需要做任何事情--Swift默认会为你添加外部参数名。

下面的函数是将一个字符串自身相加：

```swift
func repeatString(s:String, times:Int) -> String {
  var result = ""
  for _ in 1...times {
    result += s
  }
  return result
}
```
函数的第一个参数只有内部参数名称，但是第二个参数具有外部参数名--和内部参数名是一样的，下面是调用的时候：
```swift
let s = repeatString("hi", times:3)
```

在这个函数中，你可以看到外部参数名在参数之前，以冒号分割。

正如我之前说的，参数的外部名称可以和内部参数不同。在上面的函数中我更喜欢使用*times*作为外部参数名，*n*作为内部参数名。下面是改过的函数声明：
```swift
func repeatString(s:String, times n:Int) -> String {
  var result = ""
  for _ in 1...n {
    result += s
  }
  return result
}
```
在函数体内，不存在*times*变量，*times*只是一个外部名，方便函数调用。内部名称*n*才是代码中使用的。

> **注意：**
> 函数外部参数名的存在不是说你可以在调用函数的时候可以改变参数的顺序。比如，*repeatString*函数中希望一个String和Int参数，这个顺序在调用的时候不可以改变。

我们的**repeatString**函数说明了默认情况下，第一个参数是没有外部参数的，但其他参数具有。为什么这样？其中一个原因是第一个参数不需要外部名，因为函数名一般都会说明第一个参数的作用--就像在上面的函数中那样。另外一个原因是，在现实生活中更多的是--这个习惯可以方便的使Swift方法和OC方法结合。
下面是一个OC函数的声明：
```swift
- (NSString\*)stringByReplaceOccurrenceOfString:(NSString \*)target withString:(NSString \*)replacement; 
```
这个函数带有两个*NSString*类型的参数，并返回一个*NSString*类型的值。第二个参数的外部名是明显的--*withString*但是第一个参数的名字不是特别的明显。另一方面，这个不是参数的真正名字；它更多的是函数的名字。实际上，这个方法的整个名字是：*stringByReplaceOccurrenceOfString:withString:*。但是Swift函数的调用语法带有大括号来区分参数名和函数名。所以当Swift想要调用OC方法的时候，第一个冒号前面的变成了函数的名字。第二个冒号前面的变成了第二个参数的标签，处于冒号里面。Swift中的String可以和Cocoa中的NSString进行桥接。
```swift
let s = "hello"
let s2 = s.stringByReplacingOccurrencsOfString("ell", withString:"ipp")
// s2 现在是"hippo"
```
如果你声明一个你自己的函数，如果不会被OC调用，（所以没有必要遵循OC的标准），你可以不按照默认的方式声明函数。你可以使用下面的声明方式：

* 外部化第一个参数

  > 如果你希望外部化第一个参数，把外部名字放到内部名字之前，以空格分割。两个名字可以相同。

* 改变非第一个参数的外部名称
  > 如果你想改变参数的外部名称而不是第一个参数，把你希望的参数名字放到内部名字之前。

* 省略非第一个参数名
  > 为了省略非第一个参数的外部名，使*_*放到内部参数前面，以空格分割：
> ```swift
> func say(s:String, _ times:Int){}
> ```

现在这个函数在调用的时候没有第二个参数的外部名称：
```swift
let d = Dog()
d.say("woof",3)
```
(这个解释了我的在这章声明的函数*func sum(x:Int, _ y:Int) -> Int*:我省略了第二个参数的外部名称，这就是为什么外部参数标签丢失的原因)。

> *这个函数的名字是什么？*
> 
> 技术上，Swift函数的名字是大括号前面的加上参数的的名字。如果参数的名字被省略，我么使用*_*来省略了参数名。函数的名字是外部参数名字后面跟着冒号。比如，函数*func sum(x:Int, y:Int) -> Int*名字是*sum(_:y)*，而*func sum(x:Int, _ y:Int) -> Int*的名字是*sum(_:_)*。


