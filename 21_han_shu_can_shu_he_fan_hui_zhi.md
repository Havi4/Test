# 2.1 函数参数和返回值
## 函数参数和返回值

一个函数就像一个处理大量材料的机器，这像你初中的数学本子上的。你知道我的意思：在顶部有一个漏斗状的储存器，然后是大量的齿轮和轴承，然后在底部有一个产生的管道。函数就类似于这个：你添加进去一些材料，然后材料会被这个特殊的机器加工，然后产生产品。

进入的材料是输入，出来的成为输出。严格来说，一个函数要求输入带有参数；函数的输出要求有结果。比如，这里有个非常愚蠢的例子，但是非常完美的展示了一个合格的函数带有两个**int**参数，功能是两个参数相加：

```swift
func sum (x:Int,_ y:Int) ->Int {
  let result = x + y
  return result
}
```

这里的语法是非常的严格和友好的，你不会使用Swift除非你很好的理解它。我们来详细的分解下我会把第一行分成多行方便来讲解：
```swift
func sum 
(x:Int,_ y:Int)
-> Int {
  let result = x + y
  return result
}
```

* 第一行

> 这行使用了关键字**func**来声明一个函数，后面跟着函数的名称；这里就是*sum*。这个名字就是后面调用这个函数的时候使用的--目的就是为了运行这个函数包含的代码。

* 第二行

> 函数名后面跟着它的函数列表。至少需要跟着个花括号。如果这个函数带有参数，参数会在后面的花括号内，由逗号分割。每个参数都有严格的格式：参数的名字，冒号，参数的类型。这个例子中，sum函数有两个参数--都是Int，一个是名字x，一个是名字y。


> 观察两个参数名字对于这个函数来说是随意的，他们和其他被用在函数内部或者更高的作用域里是不同的。这些名字的定义使得参数值可以被引用以至于在函数体内使用。确实，参数的定义就是各种变量的定义：我们定义变量x和y可以在函数内部使用

* 第三行


> 这个特定功能的函数还在第二个参数前面声明了一个下划线**_**和一个空格。我还不打算讲解这个**_**。我在例子中需要这个，但是请相信我。

* 第四行

> 在花括号之后是**->**，跟着这个函数返回值的类型。下面就是一个大括号包含着函数体--真正的代码。

* 第五行

> 在大括号里面，就是函数体，作为参数定义的变量开始有了生命周期，它的类型在参数列表里已经指定。我们知道这个函数不会被执行除非被其他对象调用并且给这个函数传入参数。


> 这里参数的名字是x和y，所以我们可以很自信的使用这些值，可以通过名字引用这些值，保证这些值是存在的且类型为Int，正如我们在参数列表中定义的的。不仅仅编程人员很确定，我们的编译器也很确定这个事实。

* 第六行

> 如果函数具有返回值，那这个值必须跟在**return**后面，而且 这个返回值的类型必须和函数定义的返回类型相同。

> 这个例子中我返回了一个名为**result**的值；它是两个参数相加产生的结构，所以的它的类型是Int，这个类型是函数所希望的。如果我试着返回一个**String**类型的，或者我忽略返回类型，编译器会报错。


> 记住关键字**return**实际上做了两件事。一是返回对应的值，二是终止了函数的执行。在return语句后面可以跟着多行代码，但是编译器会警告你后面的代码不会执行。

在花括号前面的函数声明是对一个函数的抽象，描述了这个函数输入值是什么类型，输出值是什么样子的。根据这个概念，一个函数需要确定的参数个数，参数类型及返回值类型。一切对象都必须遵循这样的定义。在花括号内的函数体，可以将参数用作本地变量。返回值必须匹配声明的返回值类型。

这样的准则在调用这个函数的任何地方同样适用。下面是调用这个函数：
```swift
let z = sum(4,5)
```
注意等号右侧--*sum(4,5)*。这就是函数调用。它是如何组织的呢？它使用函数的名字；在名字后面跟着大括号；在大括号里面又逗号分割的是两个参数。这里我使用Int类型，唯一的要求是，我使用的参数必须符合正确的类型：
```swift
let x = 4
let y = 5
let z = sum(y,x)
```

在上面的代码里，我只是使用x和y的值作为参数。只是在调用他们的时候取了相反的位置，只是为了说明这些名字和函数体内部的名字没有关系。这些名字不会影响函数。他们的值是重点；他们的值才是参数。

这个函数的返回值呢？这个返回值是函数调用的替代，是函数调用产生的。这个过程是在前面的代码中，结果是9.所以最后一行的实际上就是
```swift
let z = 9
```

程序猿和编译器都知道这个函数的返回类型，所以它们同样知道在哪里调用这个函数合理。调用这个函数作为变量*z*的一个初始化的一部分是没有问题的，就像上面将9作为初始化的一部分：在这两个例子中，我们得到的都是Int，所以变量*z*最后被声明为*Int*。但是下面的写法是错误的：
```swift
let z = sum(4,5) + "howdy" //编译错误
```

因为**sum**的类型是**int**，上面的代码试着给Int值添加一个String值，这在Swift中是不允许的。

注意到忽略函数返回值也是合法的：
```swift
sum(4,5)
```
上面的代码是正确的；它既不会引起编译错误也不会引起运行错误。这种情况同样有点愚蠢，因为我们让**sum**函数计算4和5的值然后返回计算结果。但是，现实中有好多的情况是调用函数没有返回值的；特别的，一些函数除了返回一个值外还会做其他的操作，你调用函数的目的可能是为了其他的目的而不是返回值。

如果在任何你可以使用**Int**的地方调用**sum**函数，并且函数的参数都是**Int**类型，这是不是就是说你可以在sum函数内部使用sum呢?当然了，这个是合理的：
```swift
let z = sum(4,sum(5,6))
```

这里唯一的争议就是，你这样写会让误导你自己，并且在后面很难进行Debug。但是技术上，这个是没有问题的。

### 参数和返回值为空

让我们回到函数定义。忽略函数的参数和返回值，有两种情况可以使我们更加简洁的声明一个函数表达式：

* 定义一个没有没有返回值的函数

> 没有哪个规定函数必须有返回值。一个函数可以声明没有返回值。在这个情况下，有三种声明方式：你可以把返回值声明为**Void**类型；你也可以写为（）,一个空的括号；或者你省略箭头和返回类型。这些都是合理的：
> 1. 
> ```func say1(s:String) -> 
> Void {
> print(s)
> }```
> 2. 
> ```func say1(s:String) -> 
> () {
> print(s)
> }```
> 3. 
> ```func say1(s:String) {
> print(s)
> }```

> 如果一个函数没有返回值，那么函数体是不需要包含**return**关键字的。如果没有**return**函数最后回到函数体内语句执行完终止。


> 这个类型**ruturn**语句通常由**return**组成没有其他内容。但是**Void**在Swift中是一个实际的类型（是一个被函数返回的没有值的类型）一个没有返回值的函数技术上都是返回的这个类型，他们的返回值类型是（）。（我会在第三章讲解这个用法。）因此，说*return（）*是合理的。


> 调用一个返回空值的函数对函数是没有影响的；这只会增加表达式的复杂，所以它是这段代码的唯一一行，（）的值会被忽略。虽然，，使用Void类型的值来捕获函数返回值，比如
> ```swift
> let ponitless: Void = say1('howdy")
> ```


* 定义一个没有参数的函数

> 没有哪个法律规定函数必须带有参数的。如果一个函数没有参数，这个函数的参数声明中可以为空。但是你不可以省略包含参数的大括号！他们必须存在函数的声明中，紧接在函数名后：
> ```swift
> func greet1() -> String {
>    return "woofy"
> }
> ```

很明显，一个函数可以既没有返回值，也没有参数列表；下面是这些情况：
```swift
func greet1 -> Void { print("howdy"}
func greet2 -> () {print("howdy")}
func greet3{print("howdy")}
```
就像你在函数定义的时候不可以省略参数列表的大括号一样，你在函数调用的时候也不可以省略。如果一个函数没有参数，调用这个函数的时候大括号是空的，但是不能省略。比如：

```swift
greet1()
```
注意大括号！


### 函数类型

如果我们忽略函数声明里参数的名称，我们可以通过输入和输出的类型来标志函数，使用类似下面的表达式：
```swift
（Int,Int）-> Int
```

在Swift中这个表达式是合理的。这个是函数的签名。在这个例子中，它是函数**sum**的签名。当然它也可以是其他函数--带有两个Int参数和返回值为Int--的签名。这个签名标志了所有具有这个参数类型，和返回值类型的函数。事实上，一个签名就是一个函数的类型。函数具有类型这个对后面具有重要作用。

函数的类型必须同时包含参数列表的类型和返回值类型，即时参数列表或者返回值为空；所以，一个参数列表为空，没有返回值的函数的类型是：
```swift
Void -> Void
() -> ()
```
